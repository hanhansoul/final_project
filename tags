!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	tmp/A.h	/^struct A$/;"	s
A	tmp/t4.cpp	/^struct A$/;"	s	file:
A::a	tmp/A.h	/^    int a; $/;"	m	struct:A	access:public
A::fun	tmp/A.h	/^    int fun()$/;"	f	struct:A	access:public	signature:()
A::fun	tmp/t4.cpp	/^    int fun()$/;"	f	struct:A	access:public	signature:()
A::fun	tmp/t5.cpp	/^int A::fun()$/;"	f	class:A	signature:()
A::v	tmp/t4.cpp	/^    int v[10]; $/;"	m	struct:A	file:	access:public
DEBUG	tmp/A.h	21;"	d
DEBUG	tmp/a.cpp	21;"	d	file:
DEBUG	tmp/b.cpp	21;"	d	file:
DEBUG	tmp/map.cpp	21;"	d	file:
DEBUG	tmp/t1.cpp	21;"	d	file:
DEBUG	tmp/t2.cpp	21;"	d	file:
DEBUG	tmp/t4.cpp	21;"	d	file:
DEBUG	tmp/t5.cpp	21;"	d	file:
DEBUG	tmp/t6.cpp	21;"	d	file:
EVENT_REC	STRUCT.h	/^    EVENT_REC():ID1(0), ID2(0), start_time(0), end_time(0), num(0), interval(0)$/;"	f	struct:EVENT_REC	access:public	signature:()
EVENT_REC	STRUCT.h	/^struct EVENT_REC                      \/\/ 记录连接事件$/;"	s
EVENT_REC::EVENT_REC	STRUCT.h	/^    EVENT_REC():ID1(0), ID2(0), start_time(0), end_time(0), num(0), interval(0)$/;"	f	struct:EVENT_REC	access:public	signature:()
EVENT_REC::ID1	STRUCT.h	/^    int ID1;                    \/\/ 主动连接设备ID$/;"	m	struct:EVENT_REC	access:public
EVENT_REC::ID2	STRUCT.h	/^    int ID2;                    \/\/ 被连接设备ID$/;"	m	struct:EVENT_REC	access:public
EVENT_REC::end_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:EVENT_REC	access:public
EVENT_REC::interval	STRUCT.h	/^    int interval;               \/\/ 连接时间间隔$/;"	m	struct:EVENT_REC	access:public
EVENT_REC::num	STRUCT.h	/^    int num;                    \/\/ 连接编号$/;"	m	struct:EVENT_REC	access:public
EVENT_REC::start_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:EVENT_REC	access:public
ID	NODE.h	/^    int ID;                             \/\/ 该节点ID$/;"	m	struct:NODE	access:public
ID1	STRUCT.h	/^    int ID1;                    \/\/ 主动连接设备ID$/;"	m	struct:EVENT_REC	access:public
ID1	STRUCT.h	/^    int ID1; $/;"	m	struct:MSG	access:public
ID2	STRUCT.h	/^    int ID2;                    \/\/ 被连接设备ID$/;"	m	struct:EVENT_REC	access:public
ID2	STRUCT.h	/^    int ID2; $/;"	m	struct:MSG	access:public
INPUT_DATA_FILE	data_input.cpp	29;"	d	file:
INTERVAL_TIME	STRUCT.h	31;"	d
M	tmp/t1.cpp	/^map < int, int > M; $/;"	v
MAXN	STRUCT.h	30;"	d
MP	STRUCT.h	27;"	d
MP	tmp/map.cpp	23;"	d	file:
MP	tmp/t1.cpp	43;"	d	file:
MSG	STRUCT.h	/^    MSG()$/;"	f	struct:MSG	access:public	signature:()
MSG	STRUCT.h	/^    MSG(int ID1, int ID2, int state, VOTE vote, bool voting, int vote_level, int max_state, bool jump_vote)$/;"	f	struct:MSG	access:public	signature:(int ID1, int ID2, int state, VOTE vote, bool voting, int vote_level, int max_state, bool jump_vote)
MSG	STRUCT.h	/^struct MSG                              \/\/ 一次连接传递的信息$/;"	s
MSG::ID1	STRUCT.h	/^    int ID1; $/;"	m	struct:MSG	access:public
MSG::ID2	STRUCT.h	/^    int ID2; $/;"	m	struct:MSG	access:public
MSG::MSG	STRUCT.h	/^    MSG()$/;"	f	struct:MSG	access:public	signature:()
MSG::MSG	STRUCT.h	/^    MSG(int ID1, int ID2, int state, VOTE vote, bool voting, int vote_level, int max_state, bool jump_vote)$/;"	f	struct:MSG	access:public	signature:(int ID1, int ID2, int state, VOTE vote, bool voting, int vote_level, int max_state, bool jump_vote)
MSG::jump_vote	STRUCT.h	/^    bool jump_vote;                     \/\/ 二段投票$/;"	m	struct:MSG	access:public
MSG::max_state	STRUCT.h	/^    int max_state;                      \/\/ 相邻最大状态值$/;"	m	struct:MSG	access:public
MSG::state	STRUCT.h	/^    int state;                          \/\/ 主动连接节点的状态$/;"	m	struct:MSG	access:public
MSG::vote	STRUCT.h	/^    VOTE vote;                          \/\/ 主动连接节点票数$/;"	m	struct:MSG	access:public
MSG::vote_level	STRUCT.h	/^    int vote_level;                     \/\/ 投票种类$/;"	m	struct:MSG	access:public
MSG::voting	STRUCT.h	/^    bool voting;                        \/\/ 是否投票$/;"	m	struct:MSG	access:public
MSG_REC	STRUCT.h	/^    MSG_REC()$/;"	f	struct:MSG_REC	access:public	signature:()
MSG_REC	STRUCT.h	/^    MSG_REC(int state, VOTE vote, int max_state)$/;"	f	struct:MSG_REC	access:public	signature:(int state, VOTE vote, int max_state)
MSG_REC	STRUCT.h	/^struct MSG_REC$/;"	s
MSG_REC::MSG_REC	STRUCT.h	/^    MSG_REC()$/;"	f	struct:MSG_REC	access:public	signature:()
MSG_REC::MSG_REC	STRUCT.h	/^    MSG_REC(int state, VOTE vote, int max_state)$/;"	f	struct:MSG_REC	access:public	signature:(int state, VOTE vote, int max_state)
MSG_REC::max_state	STRUCT.h	/^    int max_state; $/;"	m	struct:MSG_REC	access:public
MSG_REC::state	STRUCT.h	/^    int state; $/;"	m	struct:MSG_REC	access:public
MSG_REC::vote	STRUCT.h	/^    VOTE vote; $/;"	m	struct:MSG_REC	access:public
M_adj_node	NODE.h	/^    map < int, MSG_REC > M_adj_node;    \/\/ 附近节点状态.该信息不是实时的.$/;"	m	struct:NODE	access:public
M_contacts_rec	NODE.h	/^    map < int, int > M_contacts_rec;            \/\/ 记录该节点与其他节点的连接次数. <i, j>与ID为i的节点连接了j次.$/;"	m	struct:NODE	access:public
NODE	NODE.h	/^struct NODE                     \/\/ NODE表示一个节点中包含的数据结构和内容.$/;"	s
NODE	tmp/q.h	/^struct NODE$/;"	s
NODE	tmp/t1.cpp	/^    NODE():a(0), b(0)$/;"	f	struct:NODE	access:public	signature:()
NODE	tmp/t1.cpp	/^    NODE(int x, int y):a(x), b(y)$/;"	f	struct:NODE	access:public	signature:(int x, int y)
NODE	tmp/t1.cpp	/^struct NODE$/;"	s	file:
NODE	tmp/t3.cpp	/^struct NODE$/;"	s	file:
NODE::ID	NODE.h	/^    int ID;                             \/\/ 该节点ID$/;"	m	struct:NODE	access:public
NODE::M_adj_node	NODE.h	/^    map < int, MSG_REC > M_adj_node;    \/\/ 附近节点状态.该信息不是实时的.$/;"	m	struct:NODE	access:public
NODE::M_contacts_rec	NODE.h	/^    map < int, int > M_contacts_rec;            \/\/ 记录该节点与其他节点的连接次数. <i, j>与ID为i的节点连接了j次.$/;"	m	struct:NODE	access:public
NODE::NODE	tmp/t1.cpp	/^    NODE():a(0), b(0)$/;"	f	struct:NODE	access:public	signature:()
NODE::NODE	tmp/t1.cpp	/^    NODE(int x, int y):a(x), b(y)$/;"	f	struct:NODE	access:public	signature:(int x, int y)
NODE::Q_max_k_heap	NODE.h	/^    vector < pair < int, int > > Q_max_k_heap;  \/\/ 保存前k大的数. < i, j > ===== < ID, 连接次数>$/;"	m	struct:NODE	access:public
NODE::Q_vote_rev	NODE.h	/^    queue < VOTE > Q_vote_rev;          \/\/ 节点获得投票, 分时间段间, 将该段时间内获得的票加入队首, 将过期的票从队尾去除.$/;"	m	struct:NODE	access:public
NODE::a	tmp/q.h	/^    int a; $/;"	m	struct:NODE	access:public
NODE::a	tmp/t1.cpp	/^    int a; $/;"	m	struct:NODE	file:	access:public
NODE::b	tmp/q.h	/^    int b; $/;"	m	struct:NODE	access:public
NODE::b	tmp/t1.cpp	/^    int b; $/;"	m	struct:NODE	file:	access:public
NODE::be_voted	NODE.h	/^    int be_voted(int from_ID, MSG msg); $/;"	p	struct:NODE	access:public	signature:(int from_ID, MSG msg)
NODE::be_voted	node_function.cpp	/^int NODE::be_voted(int from_ID, MSG msg)             \/\/ 被投票$/;"	f	class:NODE	signature:(int from_ID, MSG msg)
NODE::connect	NODE.h	/^    MSG connect(int ID); $/;"	p	struct:NODE	access:public	signature:(int ID)
NODE::connect	node_function.cpp	/^MSG NODE::connect(int ID)               \/\/ 向其他节点发出连接, 根据节点ID连接, ID即为被连接节点ID$/;"	f	class:NODE	signature:(int ID)
NODE::duration	NODE.h	/^    int duration;                       \/\/ 节点启动后持续运作的时间 $/;"	m	struct:NODE	access:public
NODE::init	tmp/q.h	/^    int init(int a, int b){$/;"	f	struct:NODE	access:public	signature:(int a, int b)
NODE::max_state	NODE.h	/^    int max_state; $/;"	m	struct:NODE	access:public
NODE::state	NODE.h	/^    int state;                          \/\/ 支配值.表明该节点为支配节点或被支配节点.$/;"	m	struct:NODE	access:public
NODE::tot_vote	NODE.h	/^    VOTE tot_vote;                      \/\/ 当前节点所获得的各类票总数.$/;"	m	struct:NODE	access:public
NODE::update	NODE.h	/^    int update(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
NODE::update	node_function.cpp	/^int NODE::update(int current_time)$/;"	f	class:NODE	signature:(int current_time)
NODE::update_time	NODE.h	/^    int update_time(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
NODE::update_time	node_function.cpp	/^int NODE::update_time(int current_time)$/;"	f	class:NODE	signature:(int current_time)
NODE::v	tmp/t3.cpp	/^    int v[4]; $/;"	m	struct:NODE	file:	access:public
NODE::vote_expire	NODE.h	/^    int vote_expire(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
NODE::vote_expire	node_function.cpp	/^int NODE::vote_expire(int current_time)                 \/\/ 淘汰超过时间间隔的投票$/;"	f	class:NODE	signature:(int current_time)
NODE_H_H	NODE.h	4;"	d
Q	tmp/t1.cpp	/^vector < NODE > Q; $/;"	v
Q_contact_rec_node_based	initialization.cpp	/^vector < REC > Q_contact_rec_node_based[MAXN];      \/\/ 根据节点来记录连接$/;"	v
Q_contact_rec_time_based	initialization.cpp	/^vector < REC > Q_contact_rec_time_based;            \/\/ 根据时间轴来记录连接$/;"	v
Q_max_k_heap	NODE.h	/^    vector < pair < int, int > > Q_max_k_heap;  \/\/ 保存前k大的数. < i, j > ===== < ID, 连接次数>$/;"	m	struct:NODE	access:public
Q_node_rec	initialization.cpp	/^vector < NODE > Q_node_rec;                         \/\/ 表示每一个节点$/;"	v
Q_vote_rev	NODE.h	/^    queue < VOTE > Q_vote_rev;          \/\/ 节点获得投票, 分时间段间, 将该段时间内获得的票加入队首, 将过期的票从队尾去除.$/;"	m	struct:NODE	access:public
RESERVE_TIME	STRUCT.h	32;"	d
STRUCT_H_H	STRUCT.h	2;"	d
VOTE	STRUCT.h	/^    VOTE():time(0)$/;"	f	struct:VOTE	access:public	signature:()
VOTE	STRUCT.h	/^    VOTE(int t):time(t)$/;"	f	struct:VOTE	access:public	signature:(int t)
VOTE	STRUCT.h	/^struct VOTE{                    \/\/ 记录获得的投票$/;"	s
VOTE::VOTE	STRUCT.h	/^    VOTE():time(0)$/;"	f	struct:VOTE	access:public	signature:()
VOTE::VOTE	STRUCT.h	/^    VOTE(int t):time(t)$/;"	f	struct:VOTE	access:public	signature:(int t)
VOTE::time	STRUCT.h	/^    int time;                   \/\/ 该轮投票时间, tot_vote中无用$/;"	m	struct:VOTE	access:public
VOTE::v	STRUCT.h	/^    int v[VOTE_K];              \/\/ 各类票数$/;"	m	struct:VOTE	access:public
VOTE_K	STRUCT.h	29;"	d
_TEST_H_	tmp/header_test/test.h	2;"	d
a	tmp/A.h	/^    int a; $/;"	m	struct:A	access:public
a	tmp/q.h	/^    int a; $/;"	m	struct:NODE	access:public
a	tmp/t1.cpp	/^    int a; $/;"	m	struct:NODE	file:	access:public
add1	tmp/header_test/test.h	/^char add1[] = "www.shellbox.cn\\n";$/;"	v
add2	tmp/header_test/test.h	/^char add2[] = "www.scriptbox.cn\\n";$/;"	v
assign	data_input.cpp	/^REC assign(int ID1, int ID2, int start_time, int end_time, int num, int interval)$/;"	f	signature:(int ID1, int ID2, int start_time, int end_time, int num, int interval)
b	tmp/q.h	/^    int b; $/;"	m	struct:NODE	access:public
b	tmp/t1.cpp	/^    int b; $/;"	m	struct:NODE	file:	access:public
be_voted	NODE.h	/^    int be_voted(int from_ID, MSG msg); $/;"	p	struct:NODE	access:public	signature:(int from_ID, MSG msg)
be_voted	node_function.cpp	/^int NODE::be_voted(int from_ID, MSG msg)             \/\/ 被投票$/;"	f	class:NODE	signature:(int from_ID, MSG msg)
connect	NODE.h	/^    MSG connect(int ID); $/;"	p	struct:NODE	access:public	signature:(int ID)
connect	node_function.cpp	/^MSG NODE::connect(int ID)               \/\/ 向其他节点发出连接, 根据节点ID连接, ID即为被连接节点ID$/;"	f	class:NODE	signature:(int ID)
connection	connection.cpp	/^int connection(EVENT_REC record)$/;"	f	signature:(EVENT_REC record)
connection	experiment_test.cpp	/^int connection(EVENT_REC record); $/;"	p	file:	signature:(EVENT_REC record)
data_input	data_input.cpp	/^int data_input()$/;"	f	signature:()
data_input	main.cpp	/^int data_input(); $/;"	p	file:	signature:()
duration	NODE.h	/^    int duration;                       \/\/ 节点启动后持续运作的时间 $/;"	m	struct:NODE	access:public
end_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:EVENT_REC	access:public
ext	tmp/t4.cpp	/^int ext; $/;"	v
fun	tmp/A.h	/^    int fun()$/;"	f	struct:A	access:public	signature:()
fun	tmp/t4.cpp	/^    int fun()$/;"	f	struct:A	access:public	signature:()
fun	tmp/t5.cpp	/^int A::fun()$/;"	f	class:A	signature:()
i	tmp/header_test/test.h	/^int i = 10;$/;"	v
init	initialization.cpp	/^int init()$/;"	f	signature:()
init	main.cpp	/^int init(); $/;"	p	file:	signature:()
init	tmp/q.h	/^    int init(int a, int b){$/;"	f	struct:NODE	access:public	signature:(int a, int b)
input	tmp/a.cpp	/^void input()$/;"	f	signature:()
input	tmp/b.cpp	/^void input(); $/;"	p	file:	signature:()
interval	STRUCT.h	/^    int interval;               \/\/ 连接时间间隔$/;"	m	struct:EVENT_REC	access:public
jump_vote	STRUCT.h	/^    bool jump_vote;                     \/\/ 二段投票$/;"	m	struct:MSG	access:public
main	main.cpp	/^int main()$/;"	f	signature:()
main	tmp/b.cpp	/^int main()$/;"	f	signature:()
main	tmp/header_test/test.c	/^int main()$/;"	f
main	tmp/map.cpp	/^int main()$/;"	f	signature:()
main	tmp/t1.cpp	/^int main()$/;"	f	signature:()
main	tmp/t2.cpp	/^int main()$/;"	f	signature:()
main	tmp/t3.cpp	/^int main ()$/;"	f	signature:()
main	tmp/t4.cpp	/^int main()$/;"	f	signature:()
main	tmp/t5.cpp	/^int main()$/;"	f	signature:()
main	tmp/t6.cpp	/^int main()$/;"	f	signature:()
max_state	NODE.h	/^    int max_state; $/;"	m	struct:NODE	access:public
max_state	STRUCT.h	/^    int max_state;                      \/\/ 相邻最大状态值$/;"	m	struct:MSG	access:public
max_state	STRUCT.h	/^    int max_state; $/;"	m	struct:MSG_REC	access:public
num	STRUCT.h	/^    int num;                    \/\/ 连接编号$/;"	m	struct:EVENT_REC	access:public
simulation_time_based	experiment_test.cpp	/^int simulation_time_based()$/;"	f	signature:()
simulation_time_based	main.cpp	/^int simulation_time_based(); $/;"	p	file:	signature:()
start_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:EVENT_REC	access:public
state	NODE.h	/^    int state;                          \/\/ 支配值.表明该节点为支配节点或被支配节点.$/;"	m	struct:NODE	access:public
state	STRUCT.h	/^    int state;                          \/\/ 主动连接节点的状态$/;"	m	struct:MSG	access:public
state	STRUCT.h	/^    int state; $/;"	m	struct:MSG_REC	access:public
test1	tmp/header_test/test.c	/^extern void test1();$/;"	p	file:
test1	tmp/header_test/test.h	/^void test1();$/;"	p	signature:()
test1	tmp/header_test/test1.c	/^void test1()$/;"	f
test2	tmp/header_test/test.c	/^extern void test2();$/;"	p	file:
test2	tmp/header_test/test.h	/^void test2();$/;"	p	signature:()
test2	tmp/header_test/test2.c	/^void test2()$/;"	f
time	STRUCT.h	/^    int time;                   \/\/ 该轮投票时间, tot_vote中无用$/;"	m	struct:VOTE	access:public
time_cmp	data_input.cpp	/^bool time_cmp(const REC& t1, const REC& t2)$/;"	f	signature:(const REC& t1, const REC& t2)
tot_vote	NODE.h	/^    VOTE tot_vote;                      \/\/ 当前节点所获得的各类票总数.$/;"	m	struct:NODE	access:public
update	NODE.h	/^    int update(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
update	node_function.cpp	/^int NODE::update(int current_time)$/;"	f	class:NODE	signature:(int current_time)
update_time	NODE.h	/^    int update_time(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
update_time	node_function.cpp	/^int NODE::update_time(int current_time)$/;"	f	class:NODE	signature:(int current_time)
v	STRUCT.h	/^    int v[VOTE_K];              \/\/ 各类票数$/;"	m	struct:VOTE	access:public
v	tmp/t3.cpp	/^    int v[4]; $/;"	m	struct:NODE	file:	access:public
v	tmp/t4.cpp	/^    int v[10]; $/;"	m	struct:A	file:	access:public
vote	STRUCT.h	/^    VOTE vote;                          \/\/ 主动连接节点票数$/;"	m	struct:MSG	access:public
vote	STRUCT.h	/^    VOTE vote; $/;"	m	struct:MSG_REC	access:public
vote_expire	NODE.h	/^    int vote_expire(int current_time); $/;"	p	struct:NODE	access:public	signature:(int current_time)
vote_expire	node_function.cpp	/^int NODE::vote_expire(int current_time)                 \/\/ 淘汰超过时间间隔的投票$/;"	f	class:NODE	signature:(int current_time)
vote_level	STRUCT.h	/^    int vote_level;                     \/\/ 投票种类$/;"	m	struct:MSG	access:public
voting	STRUCT.h	/^    bool voting;                        \/\/ 是否投票$/;"	m	struct:MSG	access:public
