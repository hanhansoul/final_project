!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
DEBUG	data_input.cpp	21;"	d	file:
DEBUG	experiment_test.cpp	21;"	d	file:
DEBUG	initialization.cpp	21;"	d	file:
DEBUG	main.cpp	21;"	d	file:
DEBUG	tmp/a.cpp	21;"	d	file:
DEBUG	tmp/b.cpp	21;"	d	file:
DEBUG	tmp/map.cpp	21;"	d	file:
DEBUG	tmp/t1.cpp	21;"	d	file:
ID1	STRUCT.h	/^    int ID1;                    \/\/ 主动连接设备ID$/;"	m	struct:REC	access:public
ID2	STRUCT.h	/^    int ID2;                    \/\/ 被连接设备ID$/;"	m	struct:REC	access:public
INPUT_DATA_FILE	data_input.cpp	52;"	d	file:
M	tmp/t1.cpp	/^map < int, int > M; $/;"	v
MAXN	STRUCT.h	23;"	d
MP	tmp/map.cpp	23;"	d	file:
MP	tmp/t1.cpp	43;"	d	file:
M_adj_vote	STRUCT.h	/^    map < int, VOTE > M_adj_vote;       \/\/ 附近节点获得的投票数.根据附近节点获得投票进行博弈.该信息不是实时的.$/;"	m	struct:NODE	access:public
M_contacts_rec	STRUCT.h	/^    map < int, int > M_contacts_rec;    \/\/ 记录该节点与其他节点的连接次数. <i, j>与ID为i的节点连接了j次.$/;"	m	struct:NODE	access:public
NODE	STRUCT.h	/^    NODE():state(0), duration(0)$/;"	f	struct:NODE	access:public	signature:()
NODE	STRUCT.h	/^struct NODE                     \/\/ NODE表示一个节点中包含的数据结构和内容.$/;"	s
NODE	tmp/q.h	/^struct NODE$/;"	s
NODE	tmp/t1.cpp	/^    NODE():a(0), b(0)$/;"	f	struct:NODE	access:public	signature:()
NODE	tmp/t1.cpp	/^    NODE(int x, int y):a(x), b(y)$/;"	f	struct:NODE	access:public	signature:(int x, int y)
NODE	tmp/t1.cpp	/^struct NODE$/;"	s	file:
NODE::M_adj_vote	STRUCT.h	/^    map < int, VOTE > M_adj_vote;       \/\/ 附近节点获得的投票数.根据附近节点获得投票进行博弈.该信息不是实时的.$/;"	m	struct:NODE	access:public
NODE::M_contacts_rec	STRUCT.h	/^    map < int, int > M_contacts_rec;    \/\/ 记录该节点与其他节点的连接次数. <i, j>与ID为i的节点连接了j次.$/;"	m	struct:NODE	access:public
NODE::NODE	STRUCT.h	/^    NODE():state(0), duration(0)$/;"	f	struct:NODE	access:public	signature:()
NODE::NODE	tmp/t1.cpp	/^    NODE():a(0), b(0)$/;"	f	struct:NODE	access:public	signature:()
NODE::NODE	tmp/t1.cpp	/^    NODE(int x, int y):a(x), b(y)$/;"	f	struct:NODE	access:public	signature:(int x, int y)
NODE::Q_max_k_heap	STRUCT.h	/^    priority_queue< pair<int, int>, vector< pair<int, int> >, less< pair<int, int> > > Q_max_k_heap; $/;"	m	struct:NODE	access:public
NODE::Q_vote_rev	STRUCT.h	/^    queue < VOTE > Q_vote_rev;          \/\/ 节点获得投票, 分时间段间, 将该段时间内获得的票加入队首, 将过期的票从队尾去除.$/;"	m	struct:NODE	access:public
NODE::a	tmp/q.h	/^    int a; $/;"	m	struct:NODE	access:public
NODE::a	tmp/t1.cpp	/^    int a; $/;"	m	struct:NODE	file:	access:public
NODE::b	tmp/q.h	/^    int b; $/;"	m	struct:NODE	access:public
NODE::b	tmp/t1.cpp	/^    int b; $/;"	m	struct:NODE	file:	access:public
NODE::duration	STRUCT.h	/^    int duration;                       \/\/ 节点启动后持续运作的时间 $/;"	m	struct:NODE	access:public
NODE::init	tmp/q.h	/^    int init(int a, int b){$/;"	f	struct:NODE	access:public	signature:(int a, int b)
NODE::state	STRUCT.h	/^    int state;                          \/\/ 状态.表明该节点为支配节点或被支配节点.用概率表示?$/;"	m	struct:NODE	access:public
NODE::tot_vote	STRUCT.h	/^    VOTE tot_vote;                      \/\/ 当前节点所获得的各类票总数.$/;"	m	struct:NODE	access:public
Q	tmp/t1.cpp	/^vector < NODE > Q; $/;"	v
Q_contact_rec_time_based	initialization.cpp	/^vector < REC > Q_contact_rec_time_based;            \/\/ 根据时间轴来记录连接$/;"	v
Q_max_k_heap	STRUCT.h	/^    priority_queue< pair<int, int>, vector< pair<int, int> >, less< pair<int, int> > > Q_max_k_heap; $/;"	m	struct:NODE	access:public
Q_node_rec	initialization.cpp	/^vector < NODE > Q_node_rec;                         \/\/ 表示每一个节点$/;"	v
Q_vote_rev	STRUCT.h	/^    queue < VOTE > Q_vote_rev;          \/\/ 节点获得投票, 分时间段间, 将该段时间内获得的票加入队首, 将过期的票从队尾去除.$/;"	m	struct:NODE	access:public
REC	STRUCT.h	/^    REC():ID1(0), ID2(0), start_time(0), end_time(0), num(0), interval(0)$/;"	f	struct:REC	access:public	signature:()
REC	STRUCT.h	/^struct REC                      \/\/ 记录连接事件$/;"	s
REC::ID1	STRUCT.h	/^    int ID1;                    \/\/ 主动连接设备ID$/;"	m	struct:REC	access:public
REC::ID2	STRUCT.h	/^    int ID2;                    \/\/ 被连接设备ID$/;"	m	struct:REC	access:public
REC::REC	STRUCT.h	/^    REC():ID1(0), ID2(0), start_time(0), end_time(0), num(0), interval(0)$/;"	f	struct:REC	access:public	signature:()
REC::end_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:REC	access:public
REC::interval	STRUCT.h	/^    int interval;               \/\/ 连接时间间隔$/;"	m	struct:REC	access:public
REC::num	STRUCT.h	/^    int num;                    \/\/ 连接编号$/;"	m	struct:REC	access:public
REC::start_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:REC	access:public
VOTE	STRUCT.h	/^    VOTE()$/;"	f	struct:VOTE	access:public	signature:()
VOTE	STRUCT.h	/^struct VOTE{                    \/\/ 记录获得的投票$/;"	s
VOTE::VOTE	STRUCT.h	/^    VOTE()$/;"	f	struct:VOTE	access:public	signature:()
VOTE::v	STRUCT.h	/^    int v[VOTE_K]; $/;"	m	struct:VOTE	access:public
VOTE_K	STRUCT.h	22;"	d
a	tmp/q.h	/^    int a; $/;"	m	struct:NODE	access:public
a	tmp/t1.cpp	/^    int a; $/;"	m	struct:NODE	file:	access:public
assign	data_input.cpp	/^REC assign(int ID1, int ID2, int start_time, int end_time, int num, int interval)$/;"	f	signature:(int ID1, int ID2, int start_time, int end_time, int num, int interval)
b	tmp/q.h	/^    int b; $/;"	m	struct:NODE	access:public
b	tmp/t1.cpp	/^    int b; $/;"	m	struct:NODE	file:	access:public
data_input	data_input.cpp	/^int data_input()$/;"	f	signature:()
data_input	experiment_test.cpp	/^int data_input(); $/;"	p	file:	signature:()
duration	STRUCT.h	/^    int duration;                       \/\/ 节点启动后持续运作的时间 $/;"	m	struct:NODE	access:public
end_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:REC	access:public
init	initialization.cpp	/^int init()$/;"	f	signature:()
init	tmp/q.h	/^    int init(int a, int b){$/;"	f	struct:NODE	access:public	signature:(int a, int b)
input	tmp/a.cpp	/^void input()$/;"	f	signature:()
input	tmp/b.cpp	/^void input(); $/;"	p	file:	signature:()
interval	STRUCT.h	/^    int interval;               \/\/ 连接时间间隔$/;"	m	struct:REC	access:public
main	main.cpp	/^int main()$/;"	f	signature:()
main	tmp/b.cpp	/^int main()$/;"	f	signature:()
main	tmp/map.cpp	/^int main()$/;"	f	signature:()
main	tmp/t1.cpp	/^int main()$/;"	f	signature:()
num	STRUCT.h	/^    int num;                    \/\/ 连接编号$/;"	m	struct:REC	access:public
simulation_time_based	experiment_test.cpp	/^int simulation_time_based()$/;"	f	signature:()
start_time	STRUCT.h	/^    int start_time, end_time;   \/\/ 连接开始和结束时间$/;"	m	struct:REC	access:public
state	STRUCT.h	/^    int state;                          \/\/ 状态.表明该节点为支配节点或被支配节点.用概率表示?$/;"	m	struct:NODE	access:public
time_cmp	data_input.cpp	/^bool time_cmp(const REC& t1, const REC& t2)$/;"	f	signature:(const REC& t1, const REC& t2)
tot_vote	STRUCT.h	/^    VOTE tot_vote;                      \/\/ 当前节点所获得的各类票总数.$/;"	m	struct:NODE	access:public
v	STRUCT.h	/^    int v[VOTE_K]; $/;"	m	struct:VOTE	access:public
